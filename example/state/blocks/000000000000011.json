{
    "blockHeight": 11,
    "parentBlockHash": "0xb0988b8b17bcb16c1c173513ee0e7ab670abf4b8709a70e8b507cacfe0822063",
    "miner": "0xee5392913a7930c233Aa711263f715f616114e9B",
    "hash": "0x4fa793dd0885c63601871a6e31293d863ffb5091f7ff986f06829ef8476a7923",
    "timestamp": 1739670434083,
    "transactions": [
        {
            "from": "0xee5392913a7930c233aa711263f715f616114e9b",
            "nonce": "bigint:4",
            "value": "bigint:0",
            "instructions": [
                {
                    "type": "create",
                    "contractAddress": "0x9352f038834a3ff50C95Afde74d46a1bC84477F8",
                    "contractClass": "LPPair",
                    "code": "// LPPair.js\n\n\nclass LPPair {\n    tokenA = null;\n    tokenB = null;\n    reservesA = 0n;\n    reservesB = 0n;\n    totalLiquidity = 0n;\n    liquidityBalances = {};\n    feePercent = 3n; // 0.3% (3 / 1000)\n\n\n    constructor(tokenA, tokenB) /* write */ {\n        tokenA = lower(tokenA);\n        tokenB = lower(tokenB);\n\n        asserts(tokenA, \"tokenA non fourni\");\n        asserts(tokenB, \"tokenB non fourni\");\n        asserts(tokenA !== tokenB, \"Les tokens doivent √™tre diff√©rents\");\n\n        this.tokenA = tokenA;\n        this.tokenB = tokenB;\n    }\n\n\n    async addLiquidity(amountA, amountB) /* write */ {\n        const sender = lower(caller);\n        amountA = BigInt(amountA);\n        amountB = BigInt(amountB);\n\n        //log(`[addLiquidity] üîπ D√©but - Sender: ${sender}, amountA: ${amountA}, amountB: ${amountB}`);\n\n        asserts(amountA > 0n && amountB > 0n, \"Montants invalides\");\n\n        // V√©rifier si les tokens existent\n        asserts(this.tokenA && this.tokenB, \"Paire non initialis√©e\");\n        log(`[addLiquidity] ‚úÖ Tokens d√©tect√©s: tokenA = ${this.tokenA}, tokenB = ${this.tokenB}`);\n\n\n        // V√©rifier que l'utilisateur a assez de tokens\n        const balanceA = await call(this.tokenA, \"\", \"balanceOf\", [sender]);\n        const balanceB = await call(this.tokenB, \"\", \"balanceOf\", [sender]);\n        log(`[addLiquidity] üìä Soldes avant: balanceA = ${balanceA}, balanceB = ${balanceB}`);\n\n\n        asserts(balanceA >= amountA, \"Solde insuffisant du tokenA\");\n        asserts(balanceB >= amountB, \"Solde insuffisant du tokenB\");\n\n        // V√©rifier que l'utilisateur a approuv√© l'utilisation des tokens\n        const allowanceA = await call(this.tokenA, \"\", \"allowance\", [sender, self]);\n        const allowanceB = await call(this.tokenB, \"\", \"allowance\", [sender, self]);\n        log(`[addLiquidity] üîê Allowance: allowanceA = ${allowanceA}, allowanceB = ${allowanceB}`);\n\n\n        asserts(allowanceA >= amountA, \"Autorisation insuffisante pour tokenA\");\n        asserts(allowanceB >= amountB, \"Autorisation insuffisante pour tokenB\");\n\n        // Effectuer le transfert des tokens vers la LP pair (depuis sender)\n        await call(this.tokenA, \"\", \"transferFrom\", [sender, self, amountA]);\n        await call(this.tokenB, \"\", \"transferFrom\", [sender, self, amountB]);\n        log(`[addLiquidity] üîÑ Transfert effectu√©: +${amountA} tokenA, +${amountB} tokenB`);\n\n\n        // üîπ Cas 1 : Cr√©ation du pool\n        if (this.totalLiquidity === 0n) {\n            this.reservesA = BigInt(amountA);\n            this.reservesB = BigInt(amountB);\n\n            const liquidity = BigInt(Math.round(Math.sqrt(Number(amountA) * Number(amountB))));\n\n            this.liquidityBalances[sender] = liquidity; // aka LP Tokens\n            this.totalLiquidity = liquidity;\n\n            log(`[addLiquidity] üöÄ Pool cr√©√© ! ReservesA: ${this.reservesA}, ReservesB: ${this.reservesB}, Liquidity: ${liquidity}`);\n\n            return liquidity;\n        }\n\n\n        // üîπ Cas 2 : Ajout de liquidit√© √† un pool existant\n        const optimalAmountB = (BigInt(amountA) * this.reservesB) / this.reservesA;\n        asserts(amountB >= optimalAmountB, \"D√©s√©quilibre de la paire\");\n\n        const liquidity = (BigInt(amountA) * this.totalLiquidity) / this.reservesA;\n\n        // Mise √† jour des r√©serves\n        this.reservesA += BigInt(amountA);\n        this.reservesB += BigInt(amountB);\n        this.liquidityBalances[sender] = (this.liquidityBalances[sender] || 0n) + liquidity;\n        this.totalLiquidity += liquidity;\n\n        asserts(this.reservesA * this.reservesB >= (this.totalLiquidity ** 2n), \"[addLiquidity] Incoh√©rence dans les r√©serves et la liquidit√© totale\");\n\n\n        log(`[addLiquidity] ‚úÖ Ajout r√©ussi: ReservesA: ${this.reservesA}, ReservesB: ${this.reservesB}, TotalLiquidity: ${this.totalLiquidity}`);\n\n        return liquidity;\n    }\n\n\n    async removeLiquidity(liquidityAmount) /* write */ {\n        const sender = lower(caller);\n        liquidityAmount = BigInt(liquidityAmount);\n\n        asserts(liquidityAmount > 0n, \"Montant invalide\");\n        asserts(this.liquidityBalances[sender] >= liquidityAmount, \"Fonds insuffisants\");\n\n        // Calcul de la part des r√©serves √† retirer\n        const amountA = (liquidityAmount * this.reservesA) / this.totalLiquidity;\n        const amountB = (liquidityAmount * this.reservesB) / this.totalLiquidity;\n\n        // Mise √† jour des r√©serves et des LP tokens\n        this.reservesA -= amountA;\n        this.reservesB -= amountB;\n        this.totalLiquidity -= liquidityAmount;\n        this.liquidityBalances[sender] -= liquidityAmount;\n\n        asserts(this.reservesA * this.reservesB >= (this.totalLiquidity ** 2n), \"[addLiquidity] Incoh√©rence dans les r√©serves et la liquidit√© totale\");\n\n        // Transf√©rer les tokens directement √† l'utilisateur\n        await call(this.tokenA, \"\", \"transfer\", [sender, amountA]);\n        await call(this.tokenB, \"\", \"transfer\", [sender, amountB]);\n\n        return { amountA, amountB };\n    }\n\n\n    getAmountOut(amountIn, reserveIn, reserveOut) {\n        amountIn = BigInt(amountIn),\n        reserveIn = BigInt(reserveIn),\n        reserveOut = BigInt(reserveOut),\n\n        asserts(amountIn > 0n, \"Insufficient input amount\");\n        asserts(reserveIn > 0n && reserveOut > 0n, \"Insufficient liquidity\");\n\n        const feePercent = this.feePercent; // R√©cup√®re le fee depuis la m√©moire (ex: 3 = 0.3%)\n        const feeDenominator = 1000n;\n\n        const amountInWithFee = amountIn * (feeDenominator - feePercent) / feeDenominator;\n        const numerator = amountInWithFee * reserveOut;\n        const denominator = reserveIn + amountInWithFee;\n\n        return numerator / denominator;\n    }\n\n\n    async swap(tokenIn, amountIn) /* write */ {\n        tokenIn = lower(tokenIn);\n        amountIn = BigInt(amountIn);\n\n        const sender = lower(caller); // L'utilisateur qui swap\n\n        // V√©rifier que la paire supporte ce token\n        asserts(tokenIn === this.tokenA || tokenIn === this.tokenB, \"Token invalide\");\n\n        // R√©cup√©rer les r√©serves\n        const isTokenA = tokenIn === this.tokenA;\n        const reserveIn = isTokenA ? this.reservesA : this.reservesB;\n        const reserveOut = isTokenA ? this.reservesB : this.reservesA;\n\n        // Calcul du montant de sortie avec `getAmountOut`\n        const amountOut = this.getAmountOut(amountIn, reserveIn, reserveOut);\n        asserts(amountOut > 0n, \"Montant de sortie invalide\");\n\n        // √âtape 1 : L'utilisateur envoie `amountIn` √† la LP Pair\n        await call(tokenIn, \"\", \"transferFrom\", [sender, self, amountIn]);\n\n        // √âtape 2 : La LP Pair envoie `amountOut` √† l'utilisateur\n        const tokenOut = isTokenA ? this.tokenB : this.tokenA;\n        await call(tokenOut, \"\", \"transfer\", [sender, amountOut]);\n\n        // Mise √† jour des r√©serves apr√®s le swap\n        if (isTokenA) {\n            this.reservesA += amountIn;\n            this.reservesB -= amountOut;\n        } else {\n            this.reservesB += amountIn;\n            this.reservesA -= amountOut;\n        }\n\n        asserts(\n            this.reservesA > 0n && this.reservesB > 0n,\n            \"[swap] Erreur : R√©serves invalides apr√®s √©change\"\n        );\n\n        asserts(\n            this.reservesA * this.reservesB >= (this.totalLiquidity ** 2n),\n            \"[swap] Erreur : Ratio de liquidit√© incoh√©rent apr√®s √©change\"\n        );\n\n        return amountOut; // Retourne le montant re√ßu\n    }\n\n\n    getReserves() {\n        return {\n            tokenA: this.tokenA,\n            tokenB: this.tokenB,\n            reservesA: this.reservesA,\n            reservesB: this.reservesB,\n            totalLiquidity: this.totalLiquidity\n        };\n    }\n}\n\n",
                    "contructorArgs": [
                        "0x2CaeEf4858702aE688142EE9927b95d48a7d2ced",
                        "0x93FD6B09Bb59fC60defB8967686a7c3932AAF804"
                    ],
                    "value": "bigint:0"
                }
            ],
            "hash": "0xdcf0a8cf5e7560a7c85db6001607399943327879c8b34d2efe557298dc51f401"
        },
        {
            "from": "0x",
            "nonce": "bigint:10",
            "value": "bigint:50000000000000001000",
            "instructions": [
                {
                    "type": "mint",
                    "address": "0xee5392913a7930c233Aa711263f715f616114e9B",
                    "amount": "bigint:50000000000000001000"
                }
            ],
            "hash": "0xb7e3c8b1c1e9733cff90b9a2640ef3ef29162bf1443a7171db6d1522cc66fb95"
        }
    ],
    "receipts": [
        {
            "success": true,
            "fees": "bigint:1000",
            "blockHeight": 11,
            "contractAddress": "0x9352f038834a3ff50C95Afde74d46a1bC84477F8"
        },
        {
            "success": true,
            "fees": "bigint:0",
            "blockHeight": 11,
            "contractAddress": null
        }
    ],
    "nonce": "bigint:0"
}