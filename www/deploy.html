<html>
<head>
    <meta charset="UTF-8" />
    <title>Contract Deployment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-FDcVY+g7vc5CXANbrTSg1K5qLyriCsGDYCE02Li1tXEYdNQPvLPHNE+rT2Mjei8N7fZbe0WLhw27j2SrGRpdMg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
    <div>
        <h1>Contract deployment</h1>

        <div>
            <textarea id="code" rows="20" style="width:900px"></textarea>
        </div>

        <br />

        <div>
            <button onclick="deploy()" style="width:900px">Deploy</button>
        </div>
    </div>

    <br />

    <div>
        <h1>Contract execution</h1>

        <div>
            Contract address: <input type="text" id="contractAddress" value="0xC10a2805C1610d81eA3037B041b6669CB4944251">
        </div>

        <div>
            Class: <input type="text" id="className" value="ContractToken1">
        </div>

        <div>
            Method: <input type="text" id="methodName" value="balanceOf">
        </div>

        <div>
            Args: 
            <div id="span-args">
                <input type="text" class="arg-value" value="0x0000000000000000000000000000000000000010">
            </div>

            <br />
            <button onclick="addArg()">Add arg</button>
        </div>

        <br />

        <div>
            <button onclick="callContract()" style="width:900px">Call (free)</button>
            <button onclick="executeContract()" style="width:900px">Execute (tx)</button>
        </div>

    </div>
</body>

<script>


//const contractAbi = [ "function balanceOf() returns (uint256)" ];

const contractAbi = [
    {
        "class": "ContractToken1",
        "methods": {
            "balanceOf": {
                "inputs": [
                    "_address"
                ]
            },
            "transfer": {
                "inputs": [
                    "recipient",
                    "amount"
                ]
            },
            "getCoinsBalance": {
                "inputs": []
            },
            "getTokenPrice": {
                "inputs": []
            }
        },
        "attributes": {}
    }
];


// 🔄 Convertir au format attendu par Ethers.js
const ethersAbi = convertCustomAbiToEthersFormat(contractAbi);
console.log("Ethers ABI:", ethersAbi);


async function callContractMethod(provider, contractAddress, contractAbi, className, methodName, params) {
    const contract = new ethers.Contract(contractAddress, contractAbi, provider);

    console.log(`Appel de ${methodName} avec params:`, params);

    if (params.length === 0) {
        console.warn(`⚠️ Aucun paramètre fourni pour ${methodName}`);
    }

    const result = await contract[methodName](...params);
    return result;
}


async function callContract() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    const contractAddress = document.getElementById('contractAddress').value;
    if (!contractAddress) return;

    const className = document.getElementById('className').value;
    if (!className) return;

    const methodName = document.getElementById('methodName').value;
    if (!methodName) return;

    const argsValues = [...document.getElementsByClassName('arg-value')].map(input => input.value);

    //const args = Object.fromEntries(
    //    argsNames.map((name, idx) => [name, argsValues[idx]])
    //);

    console.log("Méthode appelée:", ethersAbi.find(m => m.name === methodName));


    const result = await callContractMethod(signer, contractAddress, ethersAbi, className, methodName, argsValues);
    console.log('result:', result);

    return result;
}


async function executeContract() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    const contractAddress = document.getElementById('contractAddress').value;
    if (!contractAddress) return;

    const className = document.getElementById('className').value;
    if (!className) return;

    const methodName = document.getElementById('methodName').value;
    if (!methodName) return;

    const argsValues = [...document.getElementsByClassName('arg-value')].map(input => input.value);


    const tx = await callContractMethod(signer, contractAddress, ethersAbi, className, methodName, argsValues);
    console.log('tx:', tx);

    const receipt = await tx.wait();
    console.log('receipt:', receipt);
}


async function deploy() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    let txValue = ethers.utils.parseEther('0');

    const contractJsCode = document.getElementById('code').value;
    const constructorParams = [];
    const constructorParamsJSON = JSON.stringify(constructorParams);

    const bytecode = ethers.utils.defaultAbiCoder.encode(['string', 'string'], [contractJsCode, constructorParamsJSON]);

    const abi = [
        //"constructor(string)",
    ];

    const factory = new ethers.ContractFactory(abi, bytecode, signer)

    const deployArgs = [
        //'test ok', // TODO: constructorParams
    ];

    if (txValue.gt(0)) {
        deployArgs.push({
            value: txValue.toHexString(),
        });
    }

    const contract = await factory.deploy(...deployArgs)
        .catch(() => null);

    if (!contract) {
        console.warn('deployment canceled');
        return;
    }

    console.log('contract:', contract);

    const contractAddress = contract.address;
    console.log('contractAddress:', contractAddress);

    const deployTx = await contract.deployTransaction.wait()
        //.catch(() => null);

    if (! deployTx) {
        console.warn('deployment failed');
        return;
    }

    console.log('deployTx:', deployTx);
    console.log('Contract deployed at address', contractAddress);
}



// 🔧 Convertit ton ABI personnalisé en un format compatible Ethers.js
function convertCustomAbiToEthersFormat(customAbi) {
    const ethersAbi = [];

    for (const abiClass of customAbi) {
        for (const [methodName, methodData] of Object.entries(abiClass.methods)) {
            const inputs = (methodData.inputs ?? []).map(input => ({
                name: input,
                type: "string", // input.includes("address") ? "address" : "uint256",
            }));

            const outputs = [
                {
                    name: "", // Pas obligatoire pour ethers.js
                    type: "string",
                },
            ];

            ethersAbi.push({
                type: "function",
                name: methodName,
                inputs,
                outputs,
                stateMutability: "view", // ou "nonpayable" selon les cas
            });
        }
    }

    return ethersAbi;
}


</script>


<script type="text/template" id="code-sample">
// ContractToken1.js


class ContractToken1 {

    #memory = memory({
        supply: 10_000_000_000n * this.fulltoken,
        accounts: {
            [this.owner]: 10_000_000_000n * this.fulltoken,
        },
    });

    get name() {
        return 'Test Token';
    }

    get symbol() {
        return 'TOK';
    }

    get decimals() {
        return 9;
    }

    get owner() {
        return '0x0000000000000000000000000000000000000010';
    }


    get fulltoken() {
        return BigInt(Math.pow(10, this.decimals));
    }

    #mint(_address, amount) {
        this.#memory.supply += amount;

        this.#memory.accounts[_address] = this.#memory.accounts[_address] ?? 0n;
        this.#memory.accounts[_address] += amount;
    }

    #burn(_address, amount) {
        asserts(this.#memory.supply >= amount, `insufficient token supply : ${this.#memory.supply} < ${amount}`);
        asserts(this.#memory.accounts, 'unknown account');
        asserts(this.#memory.accounts[_address] >= amount, `insufficient token balance : ${this.#memory.accounts[_address]} < ${amount}`);
        this.#memory.accounts[_address] -= amount;
        this.#memory.supply -= amount;
    }

    balanceOf(_address) {
        return this.#memory.accounts[_address] ?? 0n;
    }

    transfer(recipient, amount) {
        this.#burn(caller, amount);
        this.#mint(recipient, amount);
    }


    getCoinsBalance() {
        log('DEBUG getCoinsBalance: START')

        const coinsBalance = balance(address);

        log('DEBUG getCoinsBalance: END')

        return coinsBalance;
    }


    getTokenPrice() {
        log('DEBUG getTokenPrice: START')

        const coinsBalance = balance(address);

        const tokensPrice = coinsBalance / this.#memory.supply;
        log('tokensPrice', tokensPrice)

        log('DEBUG getTokenPrice: END')

        return tokensPrice;
    }

}
</script>


<script>

document.getElementById('code').innerHTML = document.getElementById('code-sample').innerText;
</script>


</html>