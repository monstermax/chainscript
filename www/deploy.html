<html>
<head>
    <title>Contract Deployment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js" integrity="sha512-FDcVY+g7vc5CXANbrTSg1K5qLyriCsGDYCE02Li1tXEYdNQPvLPHNE+rT2Mjei8N7fZbe0WLhw27j2SrGRpdMg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>

<body>
    <div>
        <h1>Contract deployment</h1>

        <div>
            <textarea id="code" rows="20" style="width:900px"></textarea>
        </div>

        <br />

        <div>
            <button onclick="deploy()" style="width:900px">Deploy</button>
        </div>
    </div>

    <br />

    <div>
        <h1>Contract execution</h1>

        <div>
            Contract address: <input type="text" id="contractAddress" value="0x28EAfa5D7a29416AECcc3C5620B1F5468092fEE5">
        </div>

        <div>
            Class: <input type="text" id="className" value="ContractToken1">
        </div>

        <div>
            Method: <input type="text" id="methodName" value="balanceOf">
        </div>

        <div>
            Args: 
            <div id="span-args">
                <input type="text" class="arg-name" value="amount">
                <input type="text" class="arg-value" value="0x0000000000000000000000000000000000000010">
            </div>

            <br />
            <button onclick="addArg()">Add arg</button>
        </div>

        <br />

        <div>
            <button onclick="callContract()" style="width:900px">Call (free)</button>
            <button onclick="executeContract()" style="width:900px">Execute (tx)</button>
        </div>

    </div>
</body>

<script>


const contractAbi = [ "function balanceOf() returns (uint256)" ];


function addArg() {
    const $span = document.getElementById('span-args');
    $span.innerHTML += '<br /><input type="text" class="arg-name"><input type="text" class="arg-value">';
}

async function connectWallet() {
    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
}


async function callContractMethod(provider, contractAddress, contractAbi, className, methodName, params) {
    const contractAbi2 = [
        {
            class: className,
            methods: {
                balanceOf: { inputs: [] }
            },
        }
    ];

    const contract = new ethers.Contract(contractAddress, contractAbi, provider);
    //const result = await contract[methodName].apply(this, params);
    const result = await contract[methodName](params);

    return result;
}


async function callContract() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    const contractAddress = document.getElementById('contractAddress').value;
    if (!contractAddress) return;

    const className = document.getElementById('className').value;
    if (!className) return;

    const methodName = document.getElementById('methodName').value;
    if (!methodName) return;

    //const argsNames = [...document.getElementsByClassName('arg-name')].map(input => input.value);
    const argsValues = [...document.getElementsByClassName('arg-value')].map(input => input.value);

    //const args = Object.fromEntries(
    //    argsNames.map((name, idx) => [name, argsValues[idx]])
    //);


    const result = await callContractMethod(signer, contractAddress, contractAbi, className, methodName, []);
    console.log('result:', result);

    return result;
}


async function executeContract() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    const contractAddress = document.getElementById('contractAddress').value;
    if (!contractAddress) return;

    const className = document.getElementById('className').value;
    if (!className) return;

    const methodName = document.getElementById('methodName').value;
    if (!methodName) return;

    const argsNames = [...document.getElementsByClassName('arg-name')].map(input => input.value);
    const argsValues = [...document.getElementsByClassName('arg-value')].map(input => input.value);

    const args = Object.fromEntries(
        argsNames.map((name, idx) => [name, argsValues[idx]])
    );


    const tx = await callContractMethod(signer, contractAddress, contractAbi, className, methodName, args);
    console.log('tx:', tx);

    const receipt = await tx.wait();
    console.log('receipt:', receipt);
}


async function deploy() {
    if (! window.ethereum || ! window.ethereum.selectedAddress) {
        console.warn('Wallet not connected');
        return;
    }

    const provider = new ethers.providers.Web3Provider(window.ethereum);
    const signer = provider.getSigner();
    if (!signer) return;

    let txValue = ethers.utils.parseEther('0');

    const contractJsCode = document.getElementById('code').value;
    const constructorParams = [];
    const constructorParamsJSON = JSON.stringify(constructorParams);

    const bytecode = ethers.utils.defaultAbiCoder.encode(['string', 'string'], [contractJsCode, constructorParamsJSON]);

    const abi = [
        //"constructor(string)",
    ];

    const factory = new ethers.ContractFactory(abi, bytecode, signer)

    const deployArgs = [
        //'test ok', // TODO: constructorParams
    ];

    if (txValue.gt(0)) {
        deployArgs.push({
            value: txValue.toHexString(),
        });
    }

    const contract = await factory.deploy(...deployArgs)
        .catch(() => null);

    if (!contract) {
        console.warn('deployment canceled');
        return;
    }

    console.log('contract:', contract);

    const contractAddress = contract.address;
    console.log('contractAddress:', contractAddress);

    const deployTx = await contract.deployTransaction.wait()
        //.catch(() => null);

    if (! deployTx) {
        console.warn('deployment failed');
        return;
    }

    console.log('deployTx:', deployTx);
    console.log('Contract deployed at address', contractAddress);
}

/*
    const constructorParams: any[] = []; 
    const constructorParamsJSON = JSON.stringify(constructorParams);
    const bytecode = ethers.AbiCoder.defaultAbiCoder().encode(['string', 'string'], [contractAccount.code, constructorParamsJSON]);

    const provider = new ethers.JsonRpcProvider('http://localhost:8545');
    const pk = devPrivateKey;
    const signer = new ethers.Wallet(pk, provider);

    const abi: string[] = [
        //'function deploy()',
    ];
    const iface = new ethers.Interface(abi);
    const factory = new ethers.ContractFactory(iface, bytecode, signer)

    const nonce = await provider.getTransactionCount(signer.getAddress());

    const deployArgs = [...constructorParams];
    if (instruction.amount && instruction.amount > 0n) {
        deployArgs.push({
            value: toHex(instruction.amount),
            nonce,
        });
    }

    const contract = await factory.deploy(...deployArgs);

    const contractAddress = await contract.getAddress();
    console.log('Contract deployment to address ' + contractAddress);

    await contract.deploymentTransaction()?.wait()
        .then(() => {
            console.log('Contract deployed at address', contractAddress);
        })
        .catch(() => {
            console.warn('Contract deployment failed for address', contractAddress);
        });

*/

</script>


<script type="text/template" id="code-sample">
// ContractToken1.js


class ContractToken1 {

    #memory = memory({
        supply: 10_000_000_000n * this.fulltoken,
        accounts: {
            [this.owner]: 10_000_000_000n * this.fulltoken,
        },
    });

    get name() {
        return 'Test Token';
    }

    get symbol() {
        return 'TOK';
    }

    get decimals() {
        return 9;
    }

    get owner() {
        return '0x0000000000000000000000000000000000000010';
    }


    get fulltoken() {
        return BigInt(Math.pow(10, this.decimals));
    }

    #mint(_address, amount) {
        this.#memory.supply += amount;

        this.#memory.accounts[_address] = this.#memory.accounts[_address] ?? 0n;
        this.#memory.accounts[_address] += amount;
    }

    #burn(_address, amount) {
        asserts(this.#memory.supply >= amount, `insufficient token supply : ${this.#memory.supply} < ${amount}`);
        asserts(this.#memory.accounts, 'unknown account');
        asserts(this.#memory.accounts[_address] >= amount, `insufficient token balance : ${this.#memory.accounts[_address]} < ${amount}`);
        this.#memory.accounts[_address] -= amount;
        this.#memory.supply -= amount;
    }

    balanceOf(_address) {
        return this.#memory.accounts[_address] ?? 0n;
    }

    transfer(recipient, amount) {
        this.#burn(caller, amount);
        this.#mint(recipient, amount);
    }


    getCoinsBalance() {
        log('DEBUG getCoinsBalance: START')

        const coinsBalance = balance(address);

        log('DEBUG getCoinsBalance: END')

        return coinsBalance;
    }


    getTokenPrice() {
        log('DEBUG getTokenPrice: START')

        const coinsBalance = balance(address);

        const tokensPrice = coinsBalance / this.#memory.supply;
        log('tokensPrice', tokensPrice)

        log('DEBUG getTokenPrice: END')

        return tokensPrice;
    }

}
</script>


<script>

document.getElementById('code').innerHTML = document.getElementById('code-sample').innerText;
</script>


</html>